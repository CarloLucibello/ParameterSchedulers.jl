[{"body":"private   decay   —   function Concrete subtypes of  DecaySchedule  must implement this function for  T . Given  s ,  decay(s, t)  should return the value of the decay function at iteration  t .","id":"docstrings/ParameterSchedulers.decay.html"},{"body":"Basic schedules While ParameterSchedulers . jl has some complex scheduling capability, its core is made of two types of basic schedules:  decay schedules  and  cyclic schedules .  Each type of schedule conforms to an interface and formula which is relevant for understanding the schedules behavior, but more importantly, for creating your own custom schedules .  Still, both types of schedules can be indexed and iterated like we saw in the  getting started  tutorial .","id":"docs/tutorials/basic-schedules.html#basic-schedules"},{"body":"public   ScheduleIterator   —   parametric type Create a stateful iterator around  schedule . See also  next!","id":"docstrings/ParameterSchedulers.ScheduleIterator.html"},{"body":"public   Lambda   —   parametric type Wrap an arbitrary function  f  into a schedule . The schedule output at iteration  t  is  f(t) .","id":"docstrings/ParameterSchedulers.Lambda.html"},{"body":"private   basevalue   —   function Concrete subtypes of  DecaySchedule  must implement this function for  T . Given  s , the function should return the base value of  s .","id":"docstrings/ParameterSchedulers.basevalue.html"},{"body":"private   CyclicSchedule   —   type An abstract type for all cyclic schedules . Such schedules conform to a formula: where  s(t)  is the schedule output,  λ0  is the start value, λ1  is the end value, and  g(t)  is the cycle function . Concrete subtypes must implment  startvalue ,  endvalue  and  cycle .","id":"docstrings/ParameterSchedulers.CyclicSchedule.html"},{"body":"Available Schedules This is a table of the common schedules implemented, but ParameterSchedulers provides utilities for creating more exotic schedules as well .  You can read  this paper  for more information on the schedules below . Step(;λ, γ, step_sizes) Exponential decay by  γ  every step in  step_sizes Exp(;λ, γ) Exponential decay by  γ  every iteration Poly(;λ, p, max_iter) Polynomial decay at degree  p Inv(;λ, γ, p) Inverse decay at rate  (1 + tγ)^p Tri(;λ0, λ1, period) Triangle wave  function TriDecay2(;λ0, λ1, period) Triangle wave  function with half the amplitude every  period TriExp(;λ0, λ1, period, γ) Triangle wave  function with exponential amplitude decay at rate  γ Sin(;λ0, λ1, period) Sine function SinDecay2(;λ0, λ1, period) Sine function with half the amplitude every  period SinExp(;λ0, λ1, period) Sine function with exponential amplitude decay at rate  γ Cos(;λ0, λ1, period) Cosine function","id":"README.html#available-schedules"},{"body":"private   cycle   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s ,  cycle(s, t)  should return the value of the cycle function at iteration  t .","id":"docstrings/ParameterSchedulers.cycle.html"},{"body":"public   next!   —   function Advance  iter  by one iteration and return the next value . See also  ScheduleIterator","id":"docstrings/ParameterSchedulers.next!.html"},{"body":"private   reverse   —   function Return a reverse function such that  reverse(f, period)(t) == f(period - t) .","id":"docstrings/ParameterSchedulers.reverse.html"},{"body":"private   symmetric   —   function Return a symmetric function such that for  t ∈ [1, period / 2) , the symmetric function evaluates to  f(t) , and when  t ∈ [period / 2, period) , the symmetric functions evaluates to  f(period - t) .","id":"docstrings/ParameterSchedulers.symmetric.html"},{"body":"ParameterSchedulers Dev Build Status ParameterSchedulers . jl provides common machine learning (ML) schedulers for hyper - parameters .  Though this package is framework agnostic, a convenient interface for pairing schedules with  Flux . jl  optimizers is available .  Using this package with Flux is as simple as:","id":"README.html#parameterschedulers"},{"body":"private   startvalue   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s , the function should return the start value of  s .","id":"docstrings/ParameterSchedulers.startvalue.html"},{"body":"public   Sequence   —   parametric type A sequence of schedules . The output of this schedule is the concatenation of  schedules  where each schedule is evaluated for each step size in  step_sizes . Note that  schedules  can also be a vector of numbers (not just schedules) .","id":"docstrings/ParameterSchedulers.Sequence.html"},{"body":"private   endvalue   —   function Concrete subtypes of  CyclicSchedule  must implement this function for  T . Given  s , the function should return the end value of  s .","id":"docstrings/ParameterSchedulers.endvalue.html"},{"body":"Name Module Visibility Category  AbstractSchedule   ParameterSchedulers   private   type   CyclicSchedule   ParameterSchedulers   private   type   DecaySchedule   ParameterSchedulers   private   type   Lambda   ParameterSchedulers   public   parametric type   ScheduleIterator   ParameterSchedulers   public   parametric type   Sequence   ParameterSchedulers   public   parametric type   basevalue   ParameterSchedulers   private   function   cycle   ParameterSchedulers   private   function   decay   ParameterSchedulers   private   function   endvalue   ParameterSchedulers   private   function   next!   ParameterSchedulers   public   function   reverse   ParameterSchedulers   private   function   startvalue   ParameterSchedulers   private   function   symmetric   ParameterSchedulers   private   function ","id":"docstrings.html#docstring-index"},{"body":"Getting started All schedules types in ParameterSchedulers . jl behave as indexable iterators .  For example, we can index the simple exponential decay schedule ( Exp ) below: The indices are unitless .  So, if you index to a schedule every epoch, then the  s[i]  is parameter value at epoch  i . We can also use the schedule in an iterable context like a  for - loop: Many schedules such as  Exp  are infinite iterators, so iterating over them will result in an infinite loop .  You can use  Base.IteratorSize  to check if a schedule has infinite length . Notice that the value of  s[1]  and  s[5]  is unchanged even though we accessed the schedule once via  getindex  and again in the  for - loop .  This is because all schedules in ParameterSchedulers . jl are  immutable .  If you want a stateful schedule, then you can use  ScheduleIterator : We used  next!  to advance the stateful iterator .  Notice that  stateful_s  stores a reference to  s  and the current iteration state (which is  3  since we advanced the iterator twice) .  Also note that  ScheduleIterator  cannot be indexed (or iterated with  Base.iterate ):","id":"docs/tutorials/getting-started.html#getting-started"},{"body":"Decay schedules A decay schedule is defined by the following formula: where   is the schedule output,   is the base (initial) value, and   is the decay function .  Typically, the decay function is expected to be bounded between  , but this requirement is only suggested and not enforced . We can access the base value and evaluate the decay function through a provided interface: In most situations, you won ’ t use the interface above and rely on  getindex  or  iterate  instead . As you can see above,  Exp  is a type of decay schedule .  Below is a list of all the decay schedules implemented, and the parameters and decay functions for each one . Schedule Parameters Decay Function  Step   λ ,  γ ,  step_sizes    where    Exp   λ ,  γ     Poly   λ ,  p ,  max_iter     Inv   λ ,  γ ,  p   ","id":"docs/tutorials/basic-schedules.html#decay-schedules"},{"body":"private   AbstractSchedule   —   type All schedules should inherit from this type or its subtypes . Concrete subtypes are expected to conform to the iteration interface and implement  Base.getindex .","id":"docstrings/ParameterSchedulers.AbstractSchedule.html"},{"body":"private   DecaySchedule   —   type An abstract type for all decay schedules . Such schedules conform to a formula: where  s(t)  is the schedule output,  λ  is the base value, and  g(t)  is the decay function . Concrete subtypes must implment  basevalue  and  decay .","id":"docstrings/ParameterSchedulers.DecaySchedule.html"},{"body":"Cyclic schedules A cyclic schedule exhibits periodic behavior, and it is described by the following formula: where   is the schedule output,   and   are the start and end values, and   is the cycle function .  Similar to the decay function, the cycle function is expected to be bounded between  , but this requirement is only suggested and not enforced . We can access the start value, end value, and evaluate the cycle function through a provided interface: As with decay schedules, you won ’ t use the interface above and rely on  getindex  and  iterate  for most use - cases . Tri  (used in the above example) is a type of cyclic schedule .  Below is a list of all the cyclic schedules implemented, and the parameters and cycle functions for each one . Schedule Parameters Cycle Function  Tri   λ0 ,  λ1 ,  period     TriDecay2   λ0 ,  λ1 ,  period     TriExp   λ0 ,  λ1 ,  period ,  γ     Sin   λ0 ,  λ1 ,  period     SinDecay2   λ0 ,  λ1 ,  period     SinExp   λ0 ,  λ1 ,  period ,  γ     Cos   λ0 ,  λ1 ,  period   ","id":"docs/tutorials/basic-schedules.html#cyclic-schedules"}]